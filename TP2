mport cv2
import numpy as np
import matplotlib.pyplot as plt
import os

# Constantes
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
IMAGE_DIR = BASE_DIR
RESULTS_DIR = os.path.join(BASE_DIR, 'results')
FIGURE_SIZE = (15, 10)
IMAGE_LIST = ['tp21.png', 'tp22.png', 'tp23.png', 'tp24.png']

def load_image(image_path):
    """
    Charger l'image en niveaux de gris.
    """
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise ValueError(f"Impossible de charger l'image : {image_path}")
    return image

def calculate_histogram(image):
    """
    Calculer l'histogramme de l'image.
    """
    hist = cv2.calcHist([image], [0], None, [256], [0, 256])
    return hist.flatten()

def gradient_edge_detection(image, threshold, ksize=3):
    """
    Détection de contours par gradient (Sobel + seuillage).
    """
    # Calculer gradients X et Y
    grad_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=ksize)
    grad_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=ksize)

    # Calculer magnitude
    magnitude = np.sqrt(grad_x**2 + grad_y**2)

    # Normaliser
    if np.max(magnitude) > 0:
        magnitude = np.uint8(255 * magnitude / np.max(magnitude))
    else:
        magnitude = np.uint8(magnitude)

    # Appliquer seuillage binaire
    _, edges = cv2.threshold(magnitude, threshold, 255, cv2.THRESH_BINARY)

    return edges

def canny_edge_detection(image, low_threshold, high_threshold, aperture_size=3, apply_blur=False, sigma=1.0):
    """
    Détection de contours par Canny.
    """
    if high_threshold <= low_threshold:
        raise ValueError(f"high_threshold ({high_threshold}) doit être supérieur à low_threshold ({low_threshold})")
    if aperture_size not in [3, 5, 7]:
        raise ValueError(f"aperture_size ({aperture_size}) doit être 3, 5 ou 7")

    if apply_blur:
        blurred = cv2.GaussianBlur(image, (5, 5), sigma)
    else:
        blurred = image

    edges = cv2.Canny(blurred, low_threshold, high_threshold, apertureSize=aperture_size)
    return edges

def visualize_edge_results(original, edges, method_name, params_str):
    """
    Créer une figure avec visualisation de l'image originale, contours et leurs histogrammes.
    """
    fig, axes = plt.subplots(2, 2, figsize=FIGURE_SIZE)
    fig.suptitle(f'Détection de Contours - {method_name}', fontsize=16)

    # Image originale
    axes[0, 0].imshow(original, cmap='gray')
    axes[0, 0].set_title('Image Originale')
    axes[0, 0].axis('off')

    # Histogramme original
    hist_orig = calculate_histogram(original)
    axes[0, 1].plot(hist_orig, color='black')
    axes[0, 1].set_title('Histogramme Original')
    axes[0, 1].set_xlabel('Valeur de Pixel')
    axes[0, 1].set_ylabel('Fréquence')
    axes[0, 1].grid(True)

    # Contours détectés
    axes[1, 0].imshow(edges, cmap='gray')
    axes[1, 0].set_title(f'Contours Détectés - {params_str}')
    axes[1, 0].axis('off')

    # Histogramme des contours
    hist_edges = calculate_histogram(edges)
    axes[1, 1].plot(hist_edges, color='black')
    axes[1, 1].set_title('Histogramme des Contours')
    axes[1, 1].set_xlabel('Valeur de Pixel')
    axes[1, 1].set_ylabel('Fréquence')
    axes[1, 1].grid(True)

    plt.tight_layout()
    return fig

def save_edge_result(figure, edges_image, image_name, method_folder, params_str):
    """
    Sauvegarder la figure et l'image de contours.
    """
    method_dir = os.path.join(RESULTS_DIR, method_folder)
    os.makedirs(method_dir, exist_ok=True)

    base_name = os.path.splitext(image_name)[0]
    fig_name = f"{base_name}_{params_str}.png"
    fig_path = os.path.join(method_dir, fig_name)
    figure.savefig(fig_path, dpi=300, bbox_inches='tight')
    plt.close(figure)

    # Sauvegarder l'image de contours
    img_name = f"{base_name}_{params_str}_edges.png"
    img_path = os.path.join(method_dir, img_name)
    cv2.imwrite(img_path, edges_image)

def create_edge_comparison_grid(image_path):
    """
    Créer une grille de comparaison pour une image.
    """
    original = load_image(image_path)
    img_name = os.path.basename(image_path)
    base_name = os.path.splitext(img_name)[0]

    # Résultats représentatifs
    gradient_edges = gradient_edge_detection(original, threshold=100, ksize=3)
    canny_edges = canny_edge_detection(original, low_threshold=50, high_threshold=150, aperture_size=3)
    canny_blur_edges = canny_edge_detection(original, 50, 150, 3, apply_blur=True, sigma=1.0)

    fig, axes = plt.subplots(4, 2, figsize=(20, 24))
    fig.suptitle(f'Comparaison des Méthodes de Détection de Contours - {img_name}', fontsize=16)

    methods = [
        ('Originale', original),
        ('Gradient (threshold=100, ksize=3)', gradient_edges),
        ('Canny (50/150, aperture=3)', canny_edges),
        ('Canny avec Flou (50/150, sigma=1.0)', canny_blur_edges)
    ]

    for i, (title, img) in enumerate(methods):
        axes[i, 0].imshow(img, cmap='gray')
        axes[i, 0].set_title(title)
        axes[i, 0].axis('off')

        hist = calculate_histogram(img)
        axes[i, 1].plot(hist, color='black')
        axes[i, 1].set_title(f'Histogramme - {title}')
        axes[i, 1].set_xlabel('Valeur de Pixel')
        axes[i, 1].set_ylabel('Fréquence')
        axes[i, 1].grid(True)

    plt.tight_layout()
    comp_dir = os.path.join(RESULTS_DIR, 'edge_comparisons')
    os.makedirs(comp_dir, exist_ok=True)
    comp_path = os.path.join(comp_dir, f'{base_name}_edge_comparison.png')
    fig.savefig(comp_path, dpi=300, bbox_inches='tight')
    plt.close(fig)

def main():
    """
    Pipeline principal d'exécution.
    """
    os.makedirs(RESULTS_DIR, exist_ok=True)
    os.makedirs(os.path.join(RESULTS_DIR, 'gradient_edge'), exist_ok=True)
    os.makedirs(os.path.join(RESULTS_DIR, 'canny_edge'), exist_ok=True)
    os.makedirs(os.path.join(RESULTS_DIR, 'edge_comparisons'), exist_ok=True)

    images = IMAGE_LIST

    for img_name in images:
        img_path = os.path.join(IMAGE_DIR, img_name)
        original = load_image(img_path)

        # Détection par gradient
        gradient_params = [
            (50, 3),
            (100, 3),
            (150, 3),
            (100, 5),
            (100, 7)
        ]
        for threshold, ksize in gradient_params:
            edges = gradient_edge_detection(original, threshold, ksize)
            params_str = f'threshold{threshold}_ksize{ksize}'
            fig = visualize_edge_results(original, edges, 'Gradient (Sobel)', params_str)
            save_edge_result(fig, edges, img_name, 'gradient_edge', params_str)

        # Détection par Canny
        canny_params = [
            (30, 100, 3, False, 1.0),
            (50, 150, 3, False, 1.0),
            (75, 200, 3, False, 1.0),
            (50, 150, 5, False, 1.0),
            (50, 150, 3, True, 1.0),
            (50, 150, 3, True, 2.0)
        ]
        for low, high, aperture, apply_blur, sigma in canny_params:
            edges = canny_edge_detection(original, low, high, aperture, apply_blur, sigma)
            params_str = f'low{low}_high{high}_ap{aperture}'
            if apply_blur:
                params_str += f'_blur{sigma}'
            fig = visualize_edge_results(original, edges, 'Canny', params_str)
            save_edge_result(fig, edges, img_name, 'canny_edge', params_str)

    # Génération des comparaisons
    for img_name in images:
        create_edge_comparison_grid(os.path.join(IMAGE_DIR, img_name))

if __name__ == '__main__':
    main()
